# 第10章 内部类
可以**将一个类的定义放在另一个类的定义内部，这就是内部类**。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而**必须要了解，内部类与组合是完全不同的概念，这一点很重要**。在**最初，内部类看起来就像是一种代码隐藏机制:将类置于其他类的内部**。但是，你将会了解到，**内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰**，尽管并不总是这样。
最初，内部类可能看起来有些奇怪，而且要花些时间才能在设计中轻松地使用它们。对内部类的需求并非总是很明显的，但是在描述完内部类的基本语法与语义之后，10.8节就应该使得内部类的益处明确显现了

## 10.2 内部类的创建与使用
内部类是一种名字隐藏和组织代码的方式。另一方面，**一个内部类的对象与外围对象(enclosing object)之间有这样的联系：内部类对象能访问其外围对象的所有成员，而需要任何特殊条件**(这与C++嵌套类的设计非常不同，在C++中只是单纯的名字隐藏机制，与外围对象没有联系，也没有隐含的访问权)
> 例一、Sequnce.java
> 关键词：**内部类**、**迭代器设计模式**
> Selector 是一个接口, 包含 end()/ current()/ next() 方法
> Suquence 类包含一个private的序列, 包含一个 add() 方法, 一个实现了
> Selector 的私有内部类 SequenceSelector

Sequence类只是一个固定大小的Object的数组，以类的形式包装了起来。可以调用 add()在序列末增加新的Object (只要还有空间)。要获取Sequence中的每一个对象，可以使用Selector接口。**这是“迭代器”设计模式的一个例子**，在本书稍后的部分将更多地学习它。Selector允许你检查序列是否到末尾了 (end())，访向当前对象 (current())，以及移到序列中的下一个对象(next())。

所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢?**当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用**。然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节，但你现在可以看到: 内部类的对象只能在与其外围类的对象相关联的情况下才能被创建(就像你应该看到的，在内部类是非static类时)。构建内部类对象时需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。


## 10.3 .this与.new
如果你需要**生成对外部类对象的引用。可以使用外部类的名字后面紧跟点和this**。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。
> DotThis.java
> 外部类有一个方法f() 和 一个内部类, 内部类有一个方法返回外部类的引用,
> 测试获取这一引用并调用f()

有时你可能想要**告知某些其他对象，去创建其某个内部类的对象**。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这是需要使用.new语法

> DotNew.java
> 演示上述语法
练习
> 在Sequence.SequenceSelector类中增加一个方法，它可以生成对外部类Sequence的引用
> 实现 Parcel3 类, 该类分别包含包装了一个整数和一个字符串的包装类，创建他们的

当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。(从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。) 这是因为此内部类一-某个接口的实现一一能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

> 实现 Parcel4 类, 主要是 移出整数和字符串包装类使之成为接口，在其内部定义私有内部类实现接口

> 创建一个含有private域和private方法的类。创建一个内部类，它有一个方法可用来修改外围类的域，并调用外围类的方法。在外围类的另一方法中，创建此内部类的对象，并且调用它的方法，然后说明对外围类对象的影响。

Parcel4中增加了一些新东西:内部类PContents是private，所以除了Parcel4，没有人能访问它。PDestination是protected，所以只有Parcel4及其子类、还有与Parcel4同一个包中的类(因为protected也给予了包访问权)能访问PDestination，其他类都不能访问PDestination。这意味着，如果客户端程序员想了解或访问这些成员，那是要受到限制的。实际上，甚至不能向下转型成private内部类(或protected内部类，除非是继承自它的子类)，因为不能访问其名字，就像在TestParcel类中看到的那样。于是，**private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节**。此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给Java编译器提供了生成更高效代码的机会

## 局部内部类
局部内部类是指定义在方法和作用域内部的类，例如可以在一个if语句块内定义一个类，这并不是说这个局部内部类是条件创建的，这个类与其他类一起的编译，但仅在if语句块内可见。
> 实现 Parcel5.java 它演示了在 destination 方法内定义PDestination类并返回它一个对象的引用

## 匿名内部类

> 实现 Parcel6.java 它演示了在 contents 方法体内创建一个匿名内部类PContents的对象并返回引用

contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起!另外，这个类是匿名的，它没有名字。这种奇怪的语法指的是 "创建一个继承自Contents的匿名类的对象"通过new表达式返回的引用被**自动向上转型为对Contents的引用**。以下介绍了更多可能的用法示例

> 1). 一个匿名类，它扩展了有非默认构造器的类.
> Warpping类包含一个接受一个整型值参数的构造器, 用于初始化一个整数域, 另外有一个方法返回该整数。实现 Parcel7.java 它包含一个创建 Warpping 匿名内部类的方法。

如果你的基类需要一个有参数的构造器，只需简单地传递合适的参数给基类的构造器即可，这里是将x传进new Wrapping(x)。

> 2). 一个匿名类，它执行字段初始化
> 也即，你可以在匿名类内部定义字段, 并借助传入的参数对字段进行初始化。实现这一示例 Parcel8.java
如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的，就像你在destination()的参数中看到的那样。

3). 一个匿名类，它通过实例初始化实现构造 (匿名类不可能有构造器)
![](./image/2023-03-01-16-55-54.png)
在此例中，不要求变量i一定是final的。因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。

## 工厂模式与匿名内部类
匿名内部类将代码变得整洁、漂亮、优雅

> 1. 重新实现 `Interfaces/Factories.java`
> 2. 重新实现 `Interfaces/Games.java`

### 内部类的其他细节
#### 嵌套类: static
**如果不需要内部类对象与其外围类对象之间有联系, 那么可以将内部类声明为static, 这通常称为嵌套类**。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，就不是这样了**嵌套类意味着:
1)要创建类的对象，并不需要其外围类的对象
2)不能从嵌套类的对象中访问非静态的外对象**
嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西.
#### 接口内部的类
正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分。你**放到接口中的任何类都自动地是public和static的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则** 你其至可以在内部类中实现其外围接口。

**内部类可以被继承吗**
10.9内部类的继承
因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联:
public class InheritInner extends WithInner.Inner (//! InheritInner() {} // Won't compileInheritInner(withInner wi) {wi,super();

## 为什么需要内部类
一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。内部类必须要回答的一个问题是:如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢?答案是“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外围类实现这个接口有什么区别呢?答案是:后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸人的原因是:每个内部类都能独立地继承自一个 (接口的) 实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响。
如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许承多个非接口类型 (译注:类或抽象类)。
为了看到更多的细节，让我们考这样一种情形，即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择:使用单一类，或者使用内部类

如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性:
1)内部类可以有多个实例，每个实都有自己的状态信息，并且与其外围类对象的信息相互独立。
2)在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类后就会展示一个这样的例子。
3)创建内部类对象的时刻并不依赖于外围类对象的创建。
4)内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体举个例子，如果Sequencejava不使用内部类，就必须声明“Sequence是一个Selector”，对于某个特定的Sequence只能有一个Selector。然而使用内部类很容易就能拥有另一个方法reverseSelector0，用它来生成一个反方向遍历序列的Selector。只有内部类才有这种灵活性。


闭包(closure) 是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象 (创建内部类的作用域)的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。
Java最引人争议的问题之一就是，人们认为Java应该包含某种类似指针的机制，以允许回调callback)。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的
对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java更小心仔细，所以没有在语言中包括指针。
通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。见下例
//: innerclasses/Callbacks.iava

这个例子进一步展示了外围类实现一个接口与内部类实现此接口之间的区别。就代码而言Callee1是简单的解决方式。Callee2继承自MyIncrement，后者已经有了一个不同的increment(方法，并且与Incrementable接口期望的increment0方法完全不相关。所以如果Callee2继承了MyIncrement，就不能为了Incrementable的用途而覆盖increment0方法，于是只能使用内部类独立地实现Incrementable。还要注意，当创建了一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口。
注意，在Callee2中除了getCallbackReference0以外，其他成员都是private的。要想建立与外部世界的任何连接，interface Incrementable都是必需的。在这里可以看到，interface是如何允许接口与接口的实现完全独立的。
内部类Closure实现了Incrementable，以提供一个返回Callee2的“钩子”(hook)一一而且是一个安全的钩子。无论谁获得此Incrementable的引用，都只能调用increment0，除此之外没有其他功能 (不像指针那样，允许你做很多事情)。
Caller的构造器需要一个Incrementable的引用作为参数 (虽然可以在任意时刻捕获回调引用)，然后在以后的某个时刻，Caller对象可以使用此引用回调Callee类。回调的价值在于它的灵活性一一可以在运行时动态地决定需要调用什么方法。这样做的好处在第22章可以看得更明显，在那里实现GUI功能的时候，到处都用到了回调


在将要介绍的控制框架(control framework)中，可以看到更多使用内部类的具体例子应用程序框架(application framework)就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题 (这是设计模式中模板方法的-个例子(参考wwwMindVeiwnet上的《Thinking in Patterns (with Java)》)。模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。

首先，接口描述了要控制的事件。因为其默认的行为是基于时间去执行控制，所以使用抽象类代替实际的接口。下面的例子包含了某些实现:
//: innerclasses/controller/Event.java

下面的文件包含了一个用来管理并触发事件的实际控制框架。Event对象被保存在List<Event>类型(读作“Event的列表”)的容器对象中，容器会在第11章中详细介绍。目前读者只需要知道add0方法用来将一个Object添加到List的尾端，size0方法用来得到List中元素的个数，foreach语法用来连续获联List中的Event，remove0方法用来从List中移除指定的Event。run0方法循环遍历eventList，寻找就绪的 (ready0)要运行的Event对象。对找到的每一个就绪的 (ready0)事件，使用对象的toString0打印其信息，调用其action0方法，然后从队列中移除此Event。

这正是内部类要做的事情，内部类允许:1)控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的action0。
2)内部能够很容易地访外围类的任成员，所以可以避免这种实现变得。如没
有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。考虑此控制框架的一个特定实现，如控制温室的运作。控制灯光、水、温度调节器的开关以及响铃和重新启动系统，每个行为都是完全不同的。控制框架的设计使得分离这些不同的代码变得非常容易。使用内部类，可以在单一的类里面产生对同一个基类Event的多种导出版本。对于温室系统的每一种行为，都继承一个新的Event内部类，并在要实现的action0中编写控制代码。

作为典型的应用程序框架，GreenhouseControls类继承自Controller:
//: innerclasses/GreenhouseControls.java// This produces a specific application of the// control system， all in a single class. Inner1classes allow you to encapsulate different// functionality for each type of event.
注意，light、water 和 thermostat都属于外围类GreenhouseControls，而这些内部类能够自由地访问那些字段，无需限定条件或特殊许可。而且，action0方法通常都涉及对某种硬件的控制。
大多数Event类看起来都很相似，但是BelI和Restart则比较特别。Bell控制响铃，然后在事件列表中增加一个Bell对象，于是过一会儿它可以再次响铃。读者可能注意到了内部类是多么像多重继承:Bell和Restart有Event的所有方法，并且似乎也拥有外围类GreenhouseContrlos的所有方法。
一个由Event对象组成的数组被递交给Restart，该数组要加到控制器上。由于Restart0也是一个Event对象，所以同样可以将Restart对象添加到Restartaction0中，以使系统能够有规律地重新启动自己。
练习24:(2)在GreenhouseControls.java中增加一个Event内部类，用以打开、关闭风扇。配置GreenhouseControlierjava以使用这些新的Event对象。练习25:(3)在GreenhouseControlsjava中继承GreenhouseControls，增加Event内部类，用以开启、关闭喷水机。写一个新版的GreenhouseControllerjava以使用这些新的Event对象。
比起面向对象编程中其他的概念来，接口和内部类更深奥复杂，比如C++就没有这些。将两者结合起来，同样能够解决C++中的用多重继承所能解决的问题。然而，多重继承在C++中被证明是相当难以使用的，相比较而言，Java的接口和内部类就容易理解多了。虽然这些特性本身是相当直观的，但是就像多态机制一样，这些特性的使用应该是设计阶段考虑的问题。随着时间的推移，读者将能够更好地识别什么情况下应该使用接口，什么情况使用内部类，或者两者同时使用。但此时，读者至少应该已经完全理解了它们的语法和语义。当见到这些语言特性实际应用时，就最终理解它们了。