---
title: "第12章异常处理"
date: 2023-03-02T15:45:00+08:00
draft: false
tags: ["Java", "Java编程思想"]
categories: ["学习笔记"]
twemoji: true
lightgallery: true
---
改进的错误恢复机制是提供代码健壮性的最强有力的方式。**错误恢复**在我们所编写的每一个程序中都是基本的要素。**Java使用异常来提供一致的错误报告模型**，使得构件能够与客户端代码可靠地沟通问题。Java中的异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成，并且通过这种方式可以使你更加自信:你的应用中没有未处理的错误。异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行。**本章将向读者介绍如何编写正确的异常处理程序，并将展示当方法出问题的时候，如何产生自定义的异常**。

随着时间的推移，人们发现，高傲的程序员们在使用程序库的时候更倾向于认为:“对，错误也许会发生，但那是别人造成的，不关我的事”。所以，程序员不去检查错误情形也就不足为奇了 (何况对某些错误情形的检查确实很无聊)。**如果的确在每次调用方法的时候都彻底地进行错误检查，代码很可能会变得难以阅读**。正是由于程序员还仍然用这些方式拼凑系统，所以他们拒绝承认这样一个事实:对于构造大型、健壮、可维护的程序而言，这种错误处理模式已经成为了主要障碍。**<u>“异常”这个词有“我对此感到意外”的意思</u>。问题出现了，你也许不清楚该如何处理，但你的确知道不应该置之不理，你要停下来，看看是不是有别人或在别的地方，能够处理这个问题。只是在当前的环境中还没有足够的信息来解决这个问题，所以就把这个问题提交到一个更高级别的环境中，在这里将作出正确的决定。** 使用异常所带来的另一个相当明显的好处是，它往往能够降低错误处理代码的复杂度,因为异常机制将保证能够捕获这个错误。并且只需在所谓的异常处理程序中处理错误.

## 异常情形(exceptional condition) -- 抛出异常
**异常情形 (exceptional condition) 是指阻止当前方法或作用域继续执行的问题**。把异常情形与普通问题相区分很重要，所谓的普通问题是指，在当前环境下能得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续下去了，因为在当前环境下无法获得必要的信息来解决问题。**你所能做的就是<u>从当前环境跳出，并且把问题提交给上一级环境</u>。这就是抛出异常时所发生的事情。**
举一个**抛出异常**的简单例子。对于对象引用t，传给你的时候可能尚未被初始化。所以在使用这个对象引用调用其方法之前，会先对引用进行检查。可以创建一个代表错误信息的对象并且将它从当前环境中“抛出”，这样就把错误信息传播到了“更大”的环境中。这被称为**抛出一个异常**，看起来像这样:
```java
if(t == null)
    throw new NullPointerException();
```
这就抛出了异常，于是在当前环境下就不必再为这个问题操心了，它将在别的地方得到处理. 具体是哪个“地方”后面很快会介绍。**异常使得我们可以将每件事都当作一个事务来考虑**，而异常可以看护着这些事务的底线. <u>**异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。**</u>在C和C++这样的语言中，这可真是个问题，尤其是C，它没有任何办法可以强制程序在出现问题时停止在某条路径上运行下去，因此我们有可能会较长时间地忽略了问题，从而陷人了完全不恰当的状态中。**异常允许我们(如果没有其他手段)强制程序停止运行，并告诉我们出现了什么问题，或者理想状态下强制程序处理问题，并返回到稳定状态**.

### new 一个异常对象
我们总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常类都有两个构造器:一个是默认构造器，另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器:
`throw new NullPointerException("t = null");`
关键字throw将产生许多有趣的结果。在使用new创建了异常对象之后，此对象的引用将传给throw。尽管返回的异常对象其类型通常与方法设计的返回类型不同，但从效果上看，它就像是从方法“返回”的。可以简单地**把异常处理看成一种不同的返回机制**，当然若过分强调这种类比的话，就会有麻烦了。另外还能**用抛出异常的方式从当前的作用域退出**。在这两种情况下,将会返回一个异常对象，然后退出方法或作用域。抛出异常与方法正常返回值的相似之处到此为止。因为异常返回的“地点”与普通方法调用返回的“地点”完全不同。(异常将在一个恰当的异常处理程序中得到解决，它的位置可能离异常被抛出的地方很远，也可能会跨越方法调用栈的许多层次。此外，**能够抛出任意类型的Throwable对象，它是异常类型的根类**。通常，对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象内部或者用异常类的名称来暗示。上一层环境通过这些信息来决定如何处理异常。通常，<u>**异常对象中仅有的信息就是异常类型**</u>，除此之外不包含任何有意义的内容。

## 捕获异常(try-catch)
要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里“尝试”各种 (可能产生异常的)方法调用，所以称为ty块。当然，抛出的异常必须在某处得到处理。这个“地点”就是异常处理程序，而且针对每个要捕获的异常，得准备相应的处理程序。
```java
try{
    // some code may get across exception
}catch(ExceptionTypeA eta){
    // handle exception eta
}catch(ExceptionTypeB etb){
    // handle exception etb
}catch(ExceptionTypeC etc){
    // handle exception etc
}
// ...
```
异常处理程序紧跟在ty块之后，以关键字catch表示. 每个catch子句(异常处理序)看起来就像是接收一个且仅接收一个特殊类型的参数的方法。可以在处理程序的内部使用标识符 (id1，id2等等)，这与方法参数的使用很相似。有时可能用不到标识符，因为异常的类型已经给了你足够的信息来对异常进行处理，但标识符并不可以省略。
> //: exceptions/FullConstructors.java
> class MyException extends Exception {}
> public class FullConstructors
> public static void f() throws MyException 
> public static void g() throws MyException 
> main()

你将看到，**对异常来说，最重要的部分就是类名**，所以本例中建立的异常类在大多数情况下已经够用了。本例的结果被打印到了控制台上，本书的输出显示系统正是在控制台上自动地捕获和测试这些结果的。但是，**你也许想通过写入System.err而将错误发送给标准错误流。通常这比把错误信息输出到System.out要好，因为System.out也许会被重定向**。如果把结果送到System.err，它就不会随System.out一起被重定向，这样更容易被用户注意
在异常处理程序中，调用了在Throwable类声明 (Exception即从此米继承)的`printStackTrace()`方法。就像从输出中看到的，它将打印“从方法调用处直到异常抛出处”的方法调用序列。这里，信息被发送到了System.out，并自动地被捕获和显示在输出中。但是，如果调用默认版本:
`e.printStackTrace();`
则信息将被输出到标准错误流

## 异常与记录日志(logging)




 